// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: consensus_types.proto

package consensus

import (
	bits "github.com/232425wxy/BFT/proto/libs/bits"
	types "github.com/232425wxy/BFT/proto/types"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// NewRoundStep is sent for every step taken in the ConsensusState.
// For every height/round/step transition
type NewRoundStep struct {
	Height                int64    `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	Round                 int32    `protobuf:"varint,2,opt,name=round,proto3" json:"round,omitempty"`
	Step                  uint32   `protobuf:"varint,3,opt,name=step,proto3" json:"step,omitempty"`
	SecondsSinceStartTime int64    `protobuf:"varint,4,opt,name=seconds_since_start_time,json=secondsSinceStartTime,proto3" json:"seconds_since_start_time,omitempty"`
	LastReplyRound        int32    `protobuf:"varint,5,opt,name=last_reply_round,json=lastReplyRound,proto3" json:"last_reply_round,omitempty"`
	XXX_NoUnkeyedLiteral  struct{} `json:"-"`
	XXX_unrecognized      []byte   `json:"-"`
	XXX_sizecache         int32    `json:"-"`
}

func (m *NewRoundStep) Reset()         { *m = NewRoundStep{} }
func (m *NewRoundStep) String() string { return proto.CompactTextString(m) }
func (*NewRoundStep) ProtoMessage()    {}
func (*NewRoundStep) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d76d5f0d01101f2, []int{0}
}
func (m *NewRoundStep) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewRoundStep) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewRoundStep.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewRoundStep) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewRoundStep.Merge(m, src)
}
func (m *NewRoundStep) XXX_Size() int {
	return m.Size()
}
func (m *NewRoundStep) XXX_DiscardUnknown() {
	xxx_messageInfo_NewRoundStep.DiscardUnknown(m)
}

var xxx_messageInfo_NewRoundStep proto.InternalMessageInfo

func (m *NewRoundStep) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *NewRoundStep) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *NewRoundStep) GetStep() uint32 {
	if m != nil {
		return m.Step
	}
	return 0
}

func (m *NewRoundStep) GetSecondsSinceStartTime() int64 {
	if m != nil {
		return m.SecondsSinceStartTime
	}
	return 0
}

func (m *NewRoundStep) GetLastReplyRound() int32 {
	if m != nil {
		return m.LastReplyRound
	}
	return 0
}

type NewValidBlock struct {
	Height               int64               `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	Round                int32               `protobuf:"varint,2,opt,name=round,proto3" json:"round,omitempty"`
	BlockPartSetHeader   types.PartSetHeader `protobuf:"bytes,3,opt,name=block_part_set_header,json=blockPartSetHeader,proto3" json:"block_part_set_header"`
	BlockParts           *bits.BitArray      `protobuf:"bytes,4,opt,name=block_parts,json=blockParts,proto3" json:"block_parts,omitempty"`
	IsReply              bool                `protobuf:"varint,5,opt,name=is_reply,json=isReply,proto3" json:"is_reply,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *NewValidBlock) Reset()         { *m = NewValidBlock{} }
func (m *NewValidBlock) String() string { return proto.CompactTextString(m) }
func (*NewValidBlock) ProtoMessage()    {}
func (*NewValidBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d76d5f0d01101f2, []int{1}
}
func (m *NewValidBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewValidBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewValidBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewValidBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewValidBlock.Merge(m, src)
}
func (m *NewValidBlock) XXX_Size() int {
	return m.Size()
}
func (m *NewValidBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_NewValidBlock.DiscardUnknown(m)
}

var xxx_messageInfo_NewValidBlock proto.InternalMessageInfo

func (m *NewValidBlock) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *NewValidBlock) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *NewValidBlock) GetBlockPartSetHeader() types.PartSetHeader {
	if m != nil {
		return m.BlockPartSetHeader
	}
	return types.PartSetHeader{}
}

func (m *NewValidBlock) GetBlockParts() *bits.BitArray {
	if m != nil {
		return m.BlockParts
	}
	return nil
}

func (m *NewValidBlock) GetIsReply() bool {
	if m != nil {
		return m.IsReply
	}
	return false
}

type PrePrepare struct {
	PrePrepare           types.PrePrepare `protobuf:"bytes,1,opt,name=PrePrepare,proto3" json:"PrePrepare"`
	XXX_NoUnkeyedLiteral struct{}         `json:"-"`
	XXX_unrecognized     []byte           `json:"-"`
	XXX_sizecache        int32            `json:"-"`
}

func (m *PrePrepare) Reset()         { *m = PrePrepare{} }
func (m *PrePrepare) String() string { return proto.CompactTextString(m) }
func (*PrePrepare) ProtoMessage()    {}
func (*PrePrepare) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d76d5f0d01101f2, []int{2}
}
func (m *PrePrepare) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrePrepare) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrePrepare.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrePrepare) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrePrepare.Merge(m, src)
}
func (m *PrePrepare) XXX_Size() int {
	return m.Size()
}
func (m *PrePrepare) XXX_DiscardUnknown() {
	xxx_messageInfo_PrePrepare.DiscardUnknown(m)
}

var xxx_messageInfo_PrePrepare proto.InternalMessageInfo

func (m *PrePrepare) GetPrePrepare() types.PrePrepare {
	if m != nil {
		return m.PrePrepare
	}
	return types.PrePrepare{}
}

type PrePreparePOL struct {
	Height               int64         `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	PrePreparePolRound   int32         `protobuf:"varint,2,opt,name=prePrepare_pol_round,json=prePreparePolRound,proto3" json:"prePrepare_pol_round,omitempty"`
	PrePreparePol        bits.BitArray `protobuf:"bytes,3,opt,name=prePrepare_pol,json=prePreparePol,proto3" json:"prePrepare_pol"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *PrePreparePOL) Reset()         { *m = PrePreparePOL{} }
func (m *PrePreparePOL) String() string { return proto.CompactTextString(m) }
func (*PrePreparePOL) ProtoMessage()    {}
func (*PrePreparePOL) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d76d5f0d01101f2, []int{3}
}
func (m *PrePreparePOL) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PrePreparePOL) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PrePreparePOL.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PrePreparePOL) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PrePreparePOL.Merge(m, src)
}
func (m *PrePreparePOL) XXX_Size() int {
	return m.Size()
}
func (m *PrePreparePOL) XXX_DiscardUnknown() {
	xxx_messageInfo_PrePreparePOL.DiscardUnknown(m)
}

var xxx_messageInfo_PrePreparePOL proto.InternalMessageInfo

func (m *PrePreparePOL) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *PrePreparePOL) GetPrePreparePolRound() int32 {
	if m != nil {
		return m.PrePreparePolRound
	}
	return 0
}

func (m *PrePreparePOL) GetPrePreparePol() bits.BitArray {
	if m != nil {
		return m.PrePreparePol
	}
	return bits.BitArray{}
}

// BlockPart is sent when gossipping a piece of the proposed block.
type BlockPart struct {
	Height               int64      `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	Round                int32      `protobuf:"varint,2,opt,name=round,proto3" json:"round,omitempty"`
	Part                 types.Part `protobuf:"bytes,3,opt,name=part,proto3" json:"part"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *BlockPart) Reset()         { *m = BlockPart{} }
func (m *BlockPart) String() string { return proto.CompactTextString(m) }
func (*BlockPart) ProtoMessage()    {}
func (*BlockPart) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d76d5f0d01101f2, []int{4}
}
func (m *BlockPart) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockPart) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockPart.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockPart) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockPart.Merge(m, src)
}
func (m *BlockPart) XXX_Size() int {
	return m.Size()
}
func (m *BlockPart) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockPart.DiscardUnknown(m)
}

var xxx_messageInfo_BlockPart proto.InternalMessageInfo

func (m *BlockPart) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BlockPart) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *BlockPart) GetPart() types.Part {
	if m != nil {
		return m.Part
	}
	return types.Part{}
}

type Vote struct {
	Vote                 *types.Vote `protobuf:"bytes,1,opt,name=vote,proto3" json:"vote,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *Vote) Reset()         { *m = Vote{} }
func (m *Vote) String() string { return proto.CompactTextString(m) }
func (*Vote) ProtoMessage()    {}
func (*Vote) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d76d5f0d01101f2, []int{5}
}
func (m *Vote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vote.Merge(m, src)
}
func (m *Vote) XXX_Size() int {
	return m.Size()
}
func (m *Vote) XXX_DiscardUnknown() {
	xxx_messageInfo_Vote.DiscardUnknown(m)
}

var xxx_messageInfo_Vote proto.InternalMessageInfo

func (m *Vote) GetVote() *types.Vote {
	if m != nil {
		return m.Vote
	}
	return nil
}

// HasVote is sent to indicate that a particular vote has been received.
type HasVote struct {
	Height               int64               `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	Round                int32               `protobuf:"varint,2,opt,name=round,proto3" json:"round,omitempty"`
	Type                 types.SignedMsgType `protobuf:"varint,3,opt,name=type,proto3,enum=types.SignedMsgType" json:"type,omitempty"`
	Index                int32               `protobuf:"varint,4,opt,name=index,proto3" json:"index,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *HasVote) Reset()         { *m = HasVote{} }
func (m *HasVote) String() string { return proto.CompactTextString(m) }
func (*HasVote) ProtoMessage()    {}
func (*HasVote) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d76d5f0d01101f2, []int{6}
}
func (m *HasVote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HasVote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HasVote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HasVote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HasVote.Merge(m, src)
}
func (m *HasVote) XXX_Size() int {
	return m.Size()
}
func (m *HasVote) XXX_DiscardUnknown() {
	xxx_messageInfo_HasVote.DiscardUnknown(m)
}

var xxx_messageInfo_HasVote proto.InternalMessageInfo

func (m *HasVote) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *HasVote) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *HasVote) GetType() types.SignedMsgType {
	if m != nil {
		return m.Type
	}
	return types.UnknownType
}

func (m *HasVote) GetIndex() int32 {
	if m != nil {
		return m.Index
	}
	return 0
}

// VoteSetMaj23 is sent to indicate that a given BlockID has seen +2/3 votes.
type VoteSetMaj23 struct {
	Height               int64               `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	Round                int32               `protobuf:"varint,2,opt,name=round,proto3" json:"round,omitempty"`
	Type                 types.SignedMsgType `protobuf:"varint,3,opt,name=type,proto3,enum=types.SignedMsgType" json:"type,omitempty"`
	BlockID              types.BlockID       `protobuf:"bytes,4,opt,name=block_id,json=blockId,proto3" json:"block_id"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *VoteSetMaj23) Reset()         { *m = VoteSetMaj23{} }
func (m *VoteSetMaj23) String() string { return proto.CompactTextString(m) }
func (*VoteSetMaj23) ProtoMessage()    {}
func (*VoteSetMaj23) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d76d5f0d01101f2, []int{7}
}
func (m *VoteSetMaj23) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoteSetMaj23) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoteSetMaj23.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoteSetMaj23) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoteSetMaj23.Merge(m, src)
}
func (m *VoteSetMaj23) XXX_Size() int {
	return m.Size()
}
func (m *VoteSetMaj23) XXX_DiscardUnknown() {
	xxx_messageInfo_VoteSetMaj23.DiscardUnknown(m)
}

var xxx_messageInfo_VoteSetMaj23 proto.InternalMessageInfo

func (m *VoteSetMaj23) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *VoteSetMaj23) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *VoteSetMaj23) GetType() types.SignedMsgType {
	if m != nil {
		return m.Type
	}
	return types.UnknownType
}

func (m *VoteSetMaj23) GetBlockID() types.BlockID {
	if m != nil {
		return m.BlockID
	}
	return types.BlockID{}
}

// VoteSetBits is sent to communicate the bit-array of votes seen for the BlockID.
type VoteSetBits struct {
	Height               int64               `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	Round                int32               `protobuf:"varint,2,opt,name=round,proto3" json:"round,omitempty"`
	Type                 types.SignedMsgType `protobuf:"varint,3,opt,name=type,proto3,enum=types.SignedMsgType" json:"type,omitempty"`
	BlockID              types.BlockID       `protobuf:"bytes,4,opt,name=block_id,json=blockId,proto3" json:"block_id"`
	Votes                bits.BitArray       `protobuf:"bytes,5,opt,name=votes,proto3" json:"votes"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *VoteSetBits) Reset()         { *m = VoteSetBits{} }
func (m *VoteSetBits) String() string { return proto.CompactTextString(m) }
func (*VoteSetBits) ProtoMessage()    {}
func (*VoteSetBits) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d76d5f0d01101f2, []int{8}
}
func (m *VoteSetBits) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoteSetBits) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoteSetBits.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoteSetBits) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoteSetBits.Merge(m, src)
}
func (m *VoteSetBits) XXX_Size() int {
	return m.Size()
}
func (m *VoteSetBits) XXX_DiscardUnknown() {
	xxx_messageInfo_VoteSetBits.DiscardUnknown(m)
}

var xxx_messageInfo_VoteSetBits proto.InternalMessageInfo

func (m *VoteSetBits) GetHeight() int64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *VoteSetBits) GetRound() int32 {
	if m != nil {
		return m.Round
	}
	return 0
}

func (m *VoteSetBits) GetType() types.SignedMsgType {
	if m != nil {
		return m.Type
	}
	return types.UnknownType
}

func (m *VoteSetBits) GetBlockID() types.BlockID {
	if m != nil {
		return m.BlockID
	}
	return types.BlockID{}
}

func (m *VoteSetBits) GetVotes() bits.BitArray {
	if m != nil {
		return m.Votes
	}
	return bits.BitArray{}
}

type Message struct {
	// Types that are valid to be assigned to Sum:
	//	*Message_NewRoundStep
	//	*Message_NewValidBlock
	//	*Message_PrePrepare
	//	*Message_PrePreparePol
	//	*Message_BlockPart
	//	*Message_Vote
	//	*Message_HasVote
	//	*Message_VoteSetMaj23
	//	*Message_VoteSetBits
	Sum                  isMessage_Sum `protobuf_oneof:"sum"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_4d76d5f0d01101f2, []int{9}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

type isMessage_Sum interface {
	isMessage_Sum()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Message_NewRoundStep struct {
	NewRoundStep *NewRoundStep `protobuf:"bytes,1,opt,name=new_round_step,json=newRoundStep,proto3,oneof" json:"new_round_step,omitempty"`
}
type Message_NewValidBlock struct {
	NewValidBlock *NewValidBlock `protobuf:"bytes,2,opt,name=new_valid_block,json=newValidBlock,proto3,oneof" json:"new_valid_block,omitempty"`
}
type Message_PrePrepare struct {
	PrePrepare *PrePrepare `protobuf:"bytes,3,opt,name=prePrepare,proto3,oneof" json:"prePrepare,omitempty"`
}
type Message_PrePreparePol struct {
	PrePreparePol *PrePreparePOL `protobuf:"bytes,4,opt,name=prePrepare_pol,json=prePreparePol,proto3,oneof" json:"prePrepare_pol,omitempty"`
}
type Message_BlockPart struct {
	BlockPart *BlockPart `protobuf:"bytes,5,opt,name=block_part,json=blockPart,proto3,oneof" json:"block_part,omitempty"`
}
type Message_Vote struct {
	Vote *Vote `protobuf:"bytes,6,opt,name=vote,proto3,oneof" json:"vote,omitempty"`
}
type Message_HasVote struct {
	HasVote *HasVote `protobuf:"bytes,7,opt,name=has_vote,json=hasVote,proto3,oneof" json:"has_vote,omitempty"`
}
type Message_VoteSetMaj23 struct {
	VoteSetMaj23 *VoteSetMaj23 `protobuf:"bytes,8,opt,name=vote_set_maj23,json=voteSetMaj23,proto3,oneof" json:"vote_set_maj23,omitempty"`
}
type Message_VoteSetBits struct {
	VoteSetBits *VoteSetBits `protobuf:"bytes,9,opt,name=vote_set_bits,json=voteSetBits,proto3,oneof" json:"vote_set_bits,omitempty"`
}

func (*Message_NewRoundStep) isMessage_Sum()  {}
func (*Message_NewValidBlock) isMessage_Sum() {}
func (*Message_PrePrepare) isMessage_Sum()    {}
func (*Message_PrePreparePol) isMessage_Sum() {}
func (*Message_BlockPart) isMessage_Sum()     {}
func (*Message_Vote) isMessage_Sum()          {}
func (*Message_HasVote) isMessage_Sum()       {}
func (*Message_VoteSetMaj23) isMessage_Sum()  {}
func (*Message_VoteSetBits) isMessage_Sum()   {}

func (m *Message) GetSum() isMessage_Sum {
	if m != nil {
		return m.Sum
	}
	return nil
}

func (m *Message) GetNewRoundStep() *NewRoundStep {
	if x, ok := m.GetSum().(*Message_NewRoundStep); ok {
		return x.NewRoundStep
	}
	return nil
}

func (m *Message) GetNewValidBlock() *NewValidBlock {
	if x, ok := m.GetSum().(*Message_NewValidBlock); ok {
		return x.NewValidBlock
	}
	return nil
}

func (m *Message) GetPrePrepare() *PrePrepare {
	if x, ok := m.GetSum().(*Message_PrePrepare); ok {
		return x.PrePrepare
	}
	return nil
}

func (m *Message) GetPrePreparePol() *PrePreparePOL {
	if x, ok := m.GetSum().(*Message_PrePreparePol); ok {
		return x.PrePreparePol
	}
	return nil
}

func (m *Message) GetBlockPart() *BlockPart {
	if x, ok := m.GetSum().(*Message_BlockPart); ok {
		return x.BlockPart
	}
	return nil
}

func (m *Message) GetVote() *Vote {
	if x, ok := m.GetSum().(*Message_Vote); ok {
		return x.Vote
	}
	return nil
}

func (m *Message) GetHasVote() *HasVote {
	if x, ok := m.GetSum().(*Message_HasVote); ok {
		return x.HasVote
	}
	return nil
}

func (m *Message) GetVoteSetMaj23() *VoteSetMaj23 {
	if x, ok := m.GetSum().(*Message_VoteSetMaj23); ok {
		return x.VoteSetMaj23
	}
	return nil
}

func (m *Message) GetVoteSetBits() *VoteSetBits {
	if x, ok := m.GetSum().(*Message_VoteSetBits); ok {
		return x.VoteSetBits
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Message) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Message_NewRoundStep)(nil),
		(*Message_NewValidBlock)(nil),
		(*Message_PrePrepare)(nil),
		(*Message_PrePreparePol)(nil),
		(*Message_BlockPart)(nil),
		(*Message_Vote)(nil),
		(*Message_HasVote)(nil),
		(*Message_VoteSetMaj23)(nil),
		(*Message_VoteSetBits)(nil),
	}
}

func init() {
	proto.RegisterType((*NewRoundStep)(nil), "consensus.NewRoundStep")
	proto.RegisterType((*NewValidBlock)(nil), "consensus.NewValidBlock")
	proto.RegisterType((*PrePrepare)(nil), "consensus.PrePrepare")
	proto.RegisterType((*PrePreparePOL)(nil), "consensus.PrePreparePOL")
	proto.RegisterType((*BlockPart)(nil), "consensus.BlockPart")
	proto.RegisterType((*Vote)(nil), "consensus.Vote")
	proto.RegisterType((*HasVote)(nil), "consensus.HasVote")
	proto.RegisterType((*VoteSetMaj23)(nil), "consensus.VoteSetMaj23")
	proto.RegisterType((*VoteSetBits)(nil), "consensus.VoteSetBits")
	proto.RegisterType((*Message)(nil), "consensus.Message")
}

func init() { proto.RegisterFile("consensus_types.proto", fileDescriptor_4d76d5f0d01101f2) }

var fileDescriptor_4d76d5f0d01101f2 = []byte{
	// 799 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x55, 0xcd, 0x6e, 0xeb, 0x44,
	0x14, 0xb6, 0xa9, 0xd3, 0x24, 0xc7, 0x4d, 0x7a, 0x19, 0x25, 0x17, 0xd3, 0x45, 0x5a, 0x19, 0x01,
	0x11, 0x8b, 0x04, 0xe5, 0x0a, 0x55, 0x02, 0xa4, 0xab, 0x5a, 0x80, 0x5c, 0x89, 0x94, 0x68, 0x52,
	0x75, 0x6b, 0x9c, 0x78, 0x94, 0x18, 0x12, 0xdb, 0xf2, 0x4c, 0x13, 0xf2, 0x22, 0x88, 0x1d, 0x12,
	0xaf, 0xc0, 0x4b, 0x74, 0x83, 0xc4, 0x92, 0x55, 0x85, 0xc2, 0x8b, 0xa0, 0x39, 0x76, 0xec, 0x49,
	0xa3, 0x2e, 0xba, 0x40, 0x62, 0x13, 0x79, 0xe6, 0x7c, 0xdf, 0xf9, 0x9b, 0xf3, 0x9d, 0x40, 0x7b,
	0x1a, 0x47, 0x9c, 0x45, 0xfc, 0x9e, 0x7b, 0x62, 0x93, 0x30, 0xde, 0x4b, 0xd2, 0x58, 0xc4, 0xa4,
	0x5e, 0x5c, 0x9f, 0xb5, 0x66, 0xf1, 0x2c, 0xc6, 0xdb, 0xbe, 0xfc, 0xca, 0x00, 0x67, 0x1f, 0x8c,
	0xa9, 0xf3, 0xcd, 0x6d, 0x3f, 0xbb, 0x47, 0x66, 0xf6, 0xab, 0x7a, 0x39, 0xfb, 0x48, 0x05, 0x2d,
	0xc2, 0x09, 0xef, 0x4f, 0x42, 0x91, 0xfd, 0xa8, 0x38, 0xfb, 0x77, 0x1d, 0x4e, 0x6e, 0xd8, 0x9a,
	0xc6, 0xf7, 0x51, 0x30, 0x16, 0x2c, 0x21, 0xaf, 0xe1, 0x78, 0xce, 0xc2, 0xd9, 0x5c, 0x58, 0xfa,
	0x85, 0xde, 0x3d, 0xa2, 0xf9, 0x89, 0xb4, 0xa0, 0x92, 0x4a, 0x90, 0xf5, 0xce, 0x85, 0xde, 0xad,
	0xd0, 0xec, 0x40, 0x08, 0x18, 0x5c, 0xb0, 0xc4, 0x3a, 0xba, 0xd0, 0xbb, 0x0d, 0x8a, 0xdf, 0xe4,
	0x12, 0x2c, 0xce, 0xa6, 0x71, 0x14, 0x70, 0x8f, 0x87, 0xd1, 0x94, 0x79, 0x5c, 0xf8, 0xa9, 0xf0,
	0x44, 0xb8, 0x64, 0x96, 0x81, 0x3e, 0xdb, 0xb9, 0x7d, 0x2c, 0xcd, 0x63, 0x69, 0xbd, 0x0d, 0x97,
	0x8c, 0x74, 0xe1, 0xd5, 0xc2, 0xe7, 0xc2, 0x4b, 0x59, 0xb2, 0xd8, 0x78, 0x59, 0xb4, 0x0a, 0x46,
	0x6b, 0xca, 0x7b, 0x2a, 0xaf, 0x31, 0x51, 0xfb, 0x2f, 0x1d, 0x1a, 0x37, 0x6c, 0x7d, 0xe7, 0x2f,
	0xc2, 0xc0, 0x59, 0xc4, 0xd3, 0x1f, 0x5f, 0x98, 0xf6, 0x10, 0xda, 0x13, 0x49, 0xf3, 0x12, 0x99,
	0x19, 0x67, 0xc2, 0x9b, 0x33, 0x3f, 0x60, 0x29, 0xd6, 0x61, 0x0e, 0x5a, 0xbd, 0xac, 0x45, 0x23,
	0x3f, 0x15, 0x63, 0x26, 0x5c, 0xb4, 0x39, 0xc6, 0xc3, 0xe3, 0xb9, 0x46, 0x09, 0x12, 0xf7, 0x2c,
	0xa4, 0x0f, 0x66, 0xe9, 0x8e, 0x63, 0x91, 0xe6, 0xa0, 0xd9, 0x93, 0xcd, 0xee, 0x39, 0xa1, 0xb8,
	0x4a, 0x53, 0x7f, 0x43, 0xa1, 0x20, 0x72, 0xf2, 0x3e, 0xd4, 0x42, 0x9e, 0xd5, 0x89, 0x15, 0xd6,
	0x68, 0x35, 0xe4, 0x58, 0x9f, 0xfd, 0x35, 0xc0, 0x28, 0x65, 0xa3, 0x94, 0x25, 0x7e, 0xca, 0xc8,
	0xa5, 0x7a, 0xc2, 0xd2, 0xcc, 0xc1, 0xbb, 0xbb, 0xec, 0x0a, 0x43, 0x9e, 0x9a, 0x02, 0xb5, 0x7f,
	0xd6, 0xa1, 0x51, 0x1e, 0x47, 0xdf, 0x7d, 0xfb, 0x6c, 0x87, 0x3e, 0x85, 0x56, 0x52, 0x00, 0xbd,
	0x24, 0x5e, 0x78, 0x6a, 0xc3, 0x48, 0x69, 0x1b, 0xc5, 0x0b, 0xec, 0x3e, 0xf9, 0x02, 0x9a, 0xfb,
	0x8c, 0xbc, 0x6d, 0x4f, 0x2a, 0xce, 0xb3, 0x6a, 0xec, 0x79, 0xb0, 0xbf, 0x87, 0xba, 0xb3, 0x6b,
	0xc4, 0x0b, 0x5f, 0xed, 0x43, 0x30, 0x64, 0x83, 0xf3, 0x68, 0xa6, 0xf2, 0x48, 0x79, 0x28, 0x34,
	0xdb, 0x1f, 0x83, 0x71, 0x17, 0x0b, 0x46, 0xce, 0xc1, 0x58, 0xc5, 0x62, 0xd7, 0xb5, 0x1d, 0x5c,
	0x9a, 0x28, 0x1a, 0xec, 0x35, 0x54, 0x5d, 0x9f, 0x23, 0xf6, 0x65, 0x89, 0x74, 0xc1, 0x90, 0xce,
	0x30, 0x91, 0x66, 0x31, 0x2d, 0xe3, 0x70, 0x16, 0xb1, 0x60, 0xc8, 0x67, 0xb7, 0x9b, 0x84, 0x51,
	0x44, 0x48, 0x7e, 0x18, 0x05, 0xec, 0x27, 0x9c, 0x89, 0x0a, 0xcd, 0x0e, 0xf6, 0x6f, 0x3a, 0x9c,
	0xc8, 0xb0, 0x63, 0x26, 0x86, 0xfe, 0x0f, 0x83, 0x37, 0xff, 0x59, 0xf8, 0xcf, 0xa1, 0x96, 0x0d,
	0x66, 0x18, 0x14, 0x53, 0x99, 0xa1, 0xf1, 0x0d, 0xae, 0xbf, 0x72, 0x4e, 0x65, 0xe3, 0xb6, 0x8f,
	0xe7, 0xd5, 0xfc, 0x82, 0x56, 0x91, 0x70, 0x1d, 0xd8, 0x7f, 0xe8, 0x60, 0xe6, 0x49, 0x3a, 0xa1,
	0xe0, 0xff, 0xc7, 0x1c, 0xc9, 0x27, 0x50, 0x91, 0x2f, 0xc9, 0x51, 0x44, 0xcf, 0x0d, 0x60, 0x06,
	0xb1, 0x7f, 0x35, 0xa0, 0x3a, 0x64, 0x9c, 0xfb, 0x33, 0x46, 0xde, 0x42, 0x33, 0x62, 0xeb, 0x6c,
	0xd0, 0x3d, 0x5c, 0x60, 0xd9, 0x90, 0xbc, 0xd7, 0x2b, 0x96, 0x6f, 0x4f, 0xdd, 0x8a, 0xae, 0x46,
	0x4f, 0x22, 0x75, 0x4b, 0x3a, 0x70, 0x2a, 0x1d, 0xac, 0xe4, 0x02, 0xf2, 0x30, 0x1b, 0x2c, 0xdf,
	0x1c, 0x58, 0xfb, 0x1e, 0xca, 0x0d, 0xe5, 0x6a, 0xb4, 0x11, 0xed, 0xad, 0xac, 0x4b, 0x80, 0x52,
	0x1a, 0xf9, 0x50, 0xb7, 0x15, 0x7a, 0x29, 0x5f, 0x57, 0xa3, 0x0a, 0x94, 0x5c, 0x1d, 0xe8, 0xcf,
	0x38, 0x88, 0xbd, 0xa7, 0x7d, 0xf7, 0xa9, 0x0a, 0xc9, 0x67, 0x00, 0xe5, 0xc6, 0xca, 0xbb, 0xd7,
	0x52, 0xe8, 0x85, 0x44, 0x5d, 0x8d, 0xd6, 0x8b, 0xc5, 0x25, 0x15, 0x88, 0x92, 0x3a, 0x46, 0xc2,
	0xa9, 0x42, 0x90, 0x93, 0xe2, 0x6a, 0x99, 0xb0, 0x48, 0x1f, 0x6a, 0x73, 0x9f, 0x7b, 0x08, 0xad,
	0x22, 0x94, 0x28, 0xd0, 0x5c, 0x73, 0xae, 0x46, 0xab, 0xf3, 0x5c, 0x7e, 0x6f, 0xa1, 0x29, 0xc1,
	0xb8, 0x89, 0x97, 0x52, 0x11, 0x56, 0xed, 0xe0, 0x3d, 0x54, 0xc1, 0xc8, 0xf7, 0x58, 0xa9, 0x02,
	0xfa, 0x12, 0x1a, 0x85, 0x03, 0x39, 0x03, 0x56, 0x1d, 0xf9, 0xaf, 0x0f, 0xf9, 0x72, 0x96, 0x5d,
	0x8d, 0x9a, 0xab, 0xf2, 0xe8, 0x54, 0xe0, 0x88, 0xdf, 0x2f, 0x9d, 0x57, 0x0f, 0xdb, 0x8e, 0xfe,
	0xe7, 0xb6, 0xa3, 0xff, 0xbd, 0xed, 0xe8, 0xbf, 0xfc, 0xd3, 0xd1, 0x26, 0xc7, 0xf8, 0x27, 0xf9,
	0xe6, 0xdf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xf5, 0x82, 0x3b, 0x59, 0xab, 0x07, 0x00, 0x00,
}

func (m *NewRoundStep) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewRoundStep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewRoundStep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.LastReplyRound != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.LastReplyRound))
		i--
		dAtA[i] = 0x28
	}
	if m.SecondsSinceStartTime != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.SecondsSinceStartTime))
		i--
		dAtA[i] = 0x20
	}
	if m.Step != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.Step))
		i--
		dAtA[i] = 0x18
	}
	if m.Round != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NewValidBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewValidBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewValidBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.IsReply {
		i--
		if m.IsReply {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.BlockParts != nil {
		{
			size, err := m.BlockParts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensusTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	{
		size, err := m.BlockPartSetHeader.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintConsensusTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Round != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PrePrepare) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrePrepare) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrePrepare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.PrePrepare.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintConsensusTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0xa
	return len(dAtA) - i, nil
}

func (m *PrePreparePOL) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrePreparePOL) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PrePreparePOL) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.PrePreparePol.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintConsensusTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.PrePreparePolRound != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.PrePreparePolRound))
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockPart) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockPart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockPart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Part.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintConsensusTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x1a
	if m.Round != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Vote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Vote != nil {
		{
			size, err := m.Vote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensusTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HasVote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HasVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HasVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Index != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Round != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VoteSetMaj23) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoteSetMaj23) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VoteSetMaj23) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.BlockID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintConsensusTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.Type != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Round != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VoteSetBits) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoteSetBits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VoteSetBits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Votes.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintConsensusTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x2a
	{
		size, err := m.BlockID.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintConsensusTypes(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x22
	if m.Type != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Round != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.Round))
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintConsensusTypes(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Sum != nil {
		{
			size := m.Sum.Size()
			i -= size
			if _, err := m.Sum.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Message_NewRoundStep) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_NewRoundStep) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NewRoundStep != nil {
		{
			size, err := m.NewRoundStep.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensusTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Message_NewValidBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_NewValidBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.NewValidBlock != nil {
		{
			size, err := m.NewValidBlock.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensusTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Message_PrePrepare) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_PrePrepare) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PrePrepare != nil {
		{
			size, err := m.PrePrepare.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensusTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Message_PrePreparePol) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_PrePreparePol) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.PrePreparePol != nil {
		{
			size, err := m.PrePreparePol.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensusTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Message_BlockPart) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_BlockPart) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BlockPart != nil {
		{
			size, err := m.BlockPart.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensusTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Message_Vote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_Vote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Vote != nil {
		{
			size, err := m.Vote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensusTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Message_HasVote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_HasVote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HasVote != nil {
		{
			size, err := m.HasVote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensusTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Message_VoteSetMaj23) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_VoteSetMaj23) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VoteSetMaj23 != nil {
		{
			size, err := m.VoteSetMaj23.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensusTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Message_VoteSetBits) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Message_VoteSetBits) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VoteSetBits != nil {
		{
			size, err := m.VoteSetBits.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensusTypes(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func encodeVarintConsensusTypes(dAtA []byte, offset int, v uint64) int {
	offset -= sovConsensusTypes(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *NewRoundStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovConsensusTypes(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovConsensusTypes(uint64(m.Round))
	}
	if m.Step != 0 {
		n += 1 + sovConsensusTypes(uint64(m.Step))
	}
	if m.SecondsSinceStartTime != 0 {
		n += 1 + sovConsensusTypes(uint64(m.SecondsSinceStartTime))
	}
	if m.LastReplyRound != 0 {
		n += 1 + sovConsensusTypes(uint64(m.LastReplyRound))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NewValidBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovConsensusTypes(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovConsensusTypes(uint64(m.Round))
	}
	l = m.BlockPartSetHeader.Size()
	n += 1 + l + sovConsensusTypes(uint64(l))
	if m.BlockParts != nil {
		l = m.BlockParts.Size()
		n += 1 + l + sovConsensusTypes(uint64(l))
	}
	if m.IsReply {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrePrepare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.PrePrepare.Size()
	n += 1 + l + sovConsensusTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PrePreparePOL) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovConsensusTypes(uint64(m.Height))
	}
	if m.PrePreparePolRound != 0 {
		n += 1 + sovConsensusTypes(uint64(m.PrePreparePolRound))
	}
	l = m.PrePreparePol.Size()
	n += 1 + l + sovConsensusTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *BlockPart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovConsensusTypes(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovConsensusTypes(uint64(m.Round))
	}
	l = m.Part.Size()
	n += 1 + l + sovConsensusTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Vote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vote != nil {
		l = m.Vote.Size()
		n += 1 + l + sovConsensusTypes(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HasVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovConsensusTypes(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovConsensusTypes(uint64(m.Round))
	}
	if m.Type != 0 {
		n += 1 + sovConsensusTypes(uint64(m.Type))
	}
	if m.Index != 0 {
		n += 1 + sovConsensusTypes(uint64(m.Index))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VoteSetMaj23) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovConsensusTypes(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovConsensusTypes(uint64(m.Round))
	}
	if m.Type != 0 {
		n += 1 + sovConsensusTypes(uint64(m.Type))
	}
	l = m.BlockID.Size()
	n += 1 + l + sovConsensusTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *VoteSetBits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovConsensusTypes(uint64(m.Height))
	}
	if m.Round != 0 {
		n += 1 + sovConsensusTypes(uint64(m.Round))
	}
	if m.Type != 0 {
		n += 1 + sovConsensusTypes(uint64(m.Type))
	}
	l = m.BlockID.Size()
	n += 1 + l + sovConsensusTypes(uint64(l))
	l = m.Votes.Size()
	n += 1 + l + sovConsensusTypes(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sum != nil {
		n += m.Sum.Size()
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Message_NewRoundStep) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewRoundStep != nil {
		l = m.NewRoundStep.Size()
		n += 1 + l + sovConsensusTypes(uint64(l))
	}
	return n
}
func (m *Message_NewValidBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.NewValidBlock != nil {
		l = m.NewValidBlock.Size()
		n += 1 + l + sovConsensusTypes(uint64(l))
	}
	return n
}
func (m *Message_PrePrepare) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrePrepare != nil {
		l = m.PrePrepare.Size()
		n += 1 + l + sovConsensusTypes(uint64(l))
	}
	return n
}
func (m *Message_PrePreparePol) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PrePreparePol != nil {
		l = m.PrePreparePol.Size()
		n += 1 + l + sovConsensusTypes(uint64(l))
	}
	return n
}
func (m *Message_BlockPart) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockPart != nil {
		l = m.BlockPart.Size()
		n += 1 + l + sovConsensusTypes(uint64(l))
	}
	return n
}
func (m *Message_Vote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vote != nil {
		l = m.Vote.Size()
		n += 1 + l + sovConsensusTypes(uint64(l))
	}
	return n
}
func (m *Message_HasVote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HasVote != nil {
		l = m.HasVote.Size()
		n += 1 + l + sovConsensusTypes(uint64(l))
	}
	return n
}
func (m *Message_VoteSetMaj23) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VoteSetMaj23 != nil {
		l = m.VoteSetMaj23.Size()
		n += 1 + l + sovConsensusTypes(uint64(l))
	}
	return n
}
func (m *Message_VoteSetBits) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VoteSetBits != nil {
		l = m.VoteSetBits.Size()
		n += 1 + l + sovConsensusTypes(uint64(l))
	}
	return n
}

func sovConsensusTypes(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozConsensusTypes(x uint64) (n int) {
	return sovConsensusTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NewRoundStep) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensusTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewRoundStep: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewRoundStep: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Step", wireType)
			}
			m.Step = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Step |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondsSinceStartTime", wireType)
			}
			m.SecondsSinceStartTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecondsSinceStartTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastReplyRound", wireType)
			}
			m.LastReplyRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastReplyRound |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConsensusTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewValidBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensusTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewValidBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewValidBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockPartSetHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BlockPartSetHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockParts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BlockParts == nil {
				m.BlockParts = &bits.BitArray{}
			}
			if err := m.BlockParts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReply", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReply = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConsensusTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrePrepare) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensusTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrePrepare: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrePrepare: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrePrepare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrePrepare.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensusTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrePreparePOL) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensusTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrePreparePOL: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrePreparePOL: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrePreparePolRound", wireType)
			}
			m.PrePreparePolRound = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrePreparePolRound |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrePreparePol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.PrePreparePol.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensusTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockPart) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensusTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockPart: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockPart: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Part", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Part.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensusTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensusTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Vote == nil {
				m.Vote = &types.Vote{}
			}
			if err := m.Vote.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensusTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HasVote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensusTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HasVote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HasVote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= types.SignedMsgType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConsensusTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoteSetMaj23) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensusTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoteSetMaj23: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoteSetMaj23: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= types.SignedMsgType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BlockID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensusTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoteSetBits) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensusTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoteSetBits: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoteSetBits: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Round", wireType)
			}
			m.Round = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Round |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= types.SignedMsgType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.BlockID.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Votes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Votes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensusTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensusTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewRoundStep", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NewRoundStep{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Message_NewRoundStep{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewValidBlock", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NewValidBlock{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Message_NewValidBlock{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrePrepare", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PrePrepare{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Message_PrePrepare{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrePreparePol", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &PrePreparePOL{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Message_PrePreparePol{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockPart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockPart{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Message_BlockPart{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Vote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Message_Vote{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasVote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HasVote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Message_HasVote{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteSetMaj23", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VoteSetMaj23{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Message_VoteSetMaj23{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteSetBits", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VoteSetBits{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Sum = &Message_VoteSetBits{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensusTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthConsensusTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipConsensusTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowConsensusTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConsensusTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthConsensusTypes
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupConsensusTypes
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthConsensusTypes
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthConsensusTypes        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowConsensusTypes          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupConsensusTypes = fmt.Errorf("proto: unexpected end of group")
)
